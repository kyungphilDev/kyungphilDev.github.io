<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KyungPhil Dev</title>
    <description>Computer Science Dept</description>
    <link>https://kyungphildev.github.io/</link>
    <atom:link href="https://kyungphildev.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 23 Jun 2021 22:23:03 +0900</pubDate>
    <lastBuildDate>Wed, 23 Jun 2021 22:23:03 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Pipeline CPU(4)- Data Forwarding</title>
        <description>&lt;blockquote&gt;
  &lt;h3 id=&quot;pipeline-cpu-목차&quot;&gt;Pipeline-CPU 목차&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Pipeline CPU(1) : Single-Cycle vs Multi-Cycle CPU&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-2/&quot;&gt;Pipeline CPU(2) : Pipeline-CPU의 간략한 이해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-3/&quot;&gt;Pipeline CPU(3) : Data Hazard(RAW)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-4/&quot;&gt;Pipeline CPU(4) : Data Forwarding&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;stall을-통한-data-hazard-해결&quot;&gt;STALL을 통한 Data Hazard 해결&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;RAW Hazard&lt;/strong&gt;를 해결하는 가장 간단한 방법은 RAW가 발생한 두 Instruction간의 거리를 3보다 멀어지도록 두 Instruction 사이에 STALL을 추가해주는 방법이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;STALL을 함으로써&lt;/strong&gt; I_OLD가 &lt;strong&gt;WB단계&lt;/strong&gt;를 거쳐서 레지스터에 값을 저장할 때까지 충분히 기다려준 이후에, &lt;strong&gt;i.e dis(I_OLD,I_YOUNG) &amp;gt; 3&lt;/strong&gt;이 되도록, I_YOUNG의 Read가 순차적으로 실행되도록 하는 것 입니다.&lt;/p&gt;

&lt;p&gt;하지만 STALL을 사용하는 것의 단점은 매번 RAW Hazard가 발생될 때마다, &lt;strong&gt;STALL이 생겨남으로 인해서 CPU의 성능이 저하가 된다는 단점이 있습니다.&lt;/strong&gt; 성능의 저하없이 더욱 효율적인 해결방안은 없을까요?&lt;/p&gt;

&lt;h2 id=&quot;data-forwarding-logic&quot;&gt;Data Forwarding Logic&lt;/h2&gt;

&lt;p&gt;STALL을 사용하는 방법보다 더욱 효과적인 방법이 &lt;strong&gt;Data Forwarding&lt;/strong&gt;을 사용하는 방법입니다. 결론부터 말하자면, &lt;strong&gt;Data Forwarding&lt;/strong&gt;을 통해서 &lt;strong&gt;dist(i,j)=1 인 LD(i.e. Load Instruction)&lt;/strong&gt;을 제외한 모든 RAW Hazard를 해결할 수가 있습니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/123098344-03c91b80-d46c-11eb-8d0c-ec72d23617f7.png&quot; width=&quot;800&quot; /&gt;&lt;br /&gt;Feature3. Pipeline diagram
&lt;/p&gt;

&lt;p&gt;매번 새로운 Instruction이 Pipeline을 통과하는 구조를 잘 살펴봅시다. 위의 &lt;strong&gt;Feature3&lt;/strong&gt;을 보면 순서대로 Instruction이 들어오는 것에 따라 각 시간 별로, 어떤 Instruction이 어느 State에서 수행되고 있는지를 확인할 수가 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sub x2, x1, x3&lt;br /&gt;
and x12, x2, x5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위의 두 Instruction을 예시로 살펴봅시다. &lt;strong&gt;x2&lt;/strong&gt;에서 dist=1 인&lt;strong&gt;(i.e. 거리가 1)인 RAW Hazard&lt;/strong&gt;가 발생하였다는 사실을 알 수 있습니다. 이전에 &lt;strong&gt;STALL을 이용한 해결방법&lt;/strong&gt;을 생각한다면, EX단계에서 ALU를 수행한 값을 &lt;strong&gt;MEM단계에서 x2에 저장할 때까지&lt;/strong&gt; &lt;strong&gt;두 번째 Instruction의 ID&lt;/strong&gt;단계는 STALL을 통해 멈춰있어야만 합니다.&lt;/p&gt;

&lt;p&gt;하지만 만약, &lt;strong&gt;EX단계의 ALU에서 계산된 값&lt;/strong&gt;을 곧바로 &lt;strong&gt;두 번째 Instruction에서의 ALU의 Input&lt;/strong&gt;으로 꽂아 줄 수 있다면 굳이 두 번째 Instruction이 ID단계에서 레지스터로 부터 x2를 읽지 않아도 잘 계산된 값을 받아올 수 있지 않을까요? 이러한 생각이 바로 Data Forwarding Logic 입니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Feature3&lt;/strong&gt;에서 확인할 수 있듯이, 첫 번째 Instruction에서 EX단계에서 계산된 값을 곧바로 STALL없이 두 번째 Instruction의 ALU의 Input으로 Forwarding 해주는 것을 확인할 수가 있습니다. 마찬가지로 &lt;strong&gt;dist=2(i.e. 거리가 2)&lt;/strong&gt;인 경우에도 비슷한 방법으로, MEM에서 가진 x2의 값을 세 번째 Instruction의 ID단계에 곧바로 읽도록 Forwarding 해주었습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dist=3(i.e. 거리가 3)&lt;/strong&gt;인 경우는 아래의 &lt;strong&gt;Feature4&lt;/strong&gt;를 통해 쉽게 이해하여 봅시다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/116329894-40c7b780-a807-11eb-8e9e-7580d0685266.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;Feature4. Forwarding diagram
&lt;/p&gt;

&lt;p&gt;거리가 3인 경우에는 &lt;strong&gt;첫 번째 Instruction이 WB단계에서 x2 레지스터에 값을 Write하는 동시에 네 번째 Instruction이 같은 위치의 x2 레지스터의 값을 Read&lt;/strong&gt; 하면서 발생하는 RAW Hazard 입니다. 하지만 이때, &lt;strong&gt;WB(Write Back)하려고 들어오는 값을 그대로 받아서 ID단계에서 사용하도록 Forwarding&lt;/strong&gt; 함으로써 Hazard를 해결할 수가 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegWrite_MEM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist=1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_WB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegWrite_WB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist=2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//dist=3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대략적인 코드 구조는 위와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data Forwarding&lt;/strong&gt; 을 이해하는데 필요한 다음의 두가지 세부 사항을 한번 살펴보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1. 가장 최근의 값을 먼저 Forwarding 해주어야 한다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2. Data forwarding으로 모든 instruction(RAW)을 해결할 수 있을까?&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-가장-최근의-값을-먼저-forwarding-해주어야-한다&quot;&gt;1. 가장 최근의 값을 먼저 Forwarding 해주어야 한다.&lt;/h3&gt;

&lt;p&gt;다음의 예시의 경우를 한 번 살펴봅시다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist(1,2)=1 (x2)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist(1,3)=2 (x2), dist(2,3)=1(x2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시와 같은 경우에 만약 3 번째 줄을 수행할 때, &lt;strong&gt;Data forwarding&lt;/strong&gt;을 &lt;strong&gt;dist=1 보다 dist=2를&lt;/strong&gt; 먼저 수행한다고 가정하여 봅시다. &lt;strong&gt;올바른 계산은 3 번째 줄에게 가장 최근인 add를 한 결과를 x2가 받아와야 할 것입니다.&lt;/strong&gt; 하지만, add를 수행하기 전인 &lt;strong&gt;sub의 결과로 부터 x2&lt;/strong&gt;를 읽어오는 &lt;strong&gt;forwarding&lt;/strong&gt;을 수행하기 때문에 올바른 결과값을 갖지 못하게되는 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;따라서 위의 &lt;strong&gt;Data Forwarding Logic&lt;/strong&gt;에서 확인할 수 있듯이, dist를 1,2,3 순서대로 즉 &lt;strong&gt;가장 가까운 값&lt;/strong&gt;으로 부터 forwarding을 먼저 수행해 주어야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;2-data-forwarding으로-모든-instructionraw을-해결할-수-있을까&quot;&gt;2. Data forwarding으로 모든 instruction(RAW)을 해결할 수 있을까?&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ld&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//dist(1,2)=1 RAW(x2)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 경우 add에서 dist=1 이므로 &lt;strong&gt;data forwarding&lt;/strong&gt;을 해주면 되지만 &lt;strong&gt;LD instruction&lt;/strong&gt;이기 때문에 문제가 발생합니다. LD instruction의 경우, ALU로 부터 계산된 값이 아닌 &lt;strong&gt;메모리를 Read 한 값을 Forwarding&lt;/strong&gt; 해주어야 하므로 &lt;strong&gt;dist=1&lt;/strong&gt;일때 한 번의 STALL을 꼭 예외적으로 필요로 합니다.&lt;/p&gt;

&lt;p&gt;따라서 위의 &lt;strong&gt;DataForwarding Logic&lt;/strong&gt;과 함께 다음의 &lt;strong&gt;STALL 조건&lt;/strong&gt;을 추가해 주어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Stall 조건&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use_rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IR_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs2_ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use_rsw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IR_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemRead_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//MemRead_EX : op=LD/LW/...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;전체적인-구현-design&quot;&gt;전체적인 구현 Design&lt;/h2&gt;

&lt;p&gt;RAW Hazard를 고려한 Data Forwarding 구현은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Data forwarding&lt;/li&gt;
  &lt;li&gt;Hazard Detection(LD의 경우, STALL)&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/116356232-f90c5480-a835-11eb-8979-b49dd1ad6250.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature3. Pipeline CPU design(Data Forwarding)
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Wed, 23 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-4/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-4/</guid>
        
        <category>data hazard</category>
        
        <category>RAW</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        <category>RAW Hazrd</category>
        
        <category>Branch Prediction</category>
        
        <category>2-bit global</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>Pipeline CPU(3)- Data Hazard</title>
        <description>&lt;blockquote&gt;
  &lt;h3 id=&quot;pipeline-cpu-목차&quot;&gt;Pipeline-CPU 목차&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Pipeline CPU(1) : Single-Cycle vs Multi-Cycle CPU&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-2/&quot;&gt;Pipeline CPU(2) : Pipeline-CPU의 간략한 이해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-3/&quot;&gt;Pipeline CPU(3) : Data Hazard(RAW)&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-4/&quot;&gt;Pipeline CPU(4) : Data Forwarding&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;세가지-주요-사항&quot;&gt;세가지 주요 사항&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Data Hazard&lt;/li&gt;
  &lt;li&gt;Control Hazard&lt;/li&gt;
  &lt;li&gt;Branch Prediction&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;이번 Post에서는 Pipeline-CPU를 구현하기 위해 꼭 알아야할 위의 세가지 주요 사항들 중에서도 &lt;strong&gt;1. Data Hazard&lt;/strong&gt;
를 해결하는 방법에 대해 구체적으로 알아봅시다.&lt;/p&gt;

&lt;h3 id=&quot;data-dependence&quot;&gt;Data Dependence&lt;/h3&gt;

&lt;p&gt;Data Dependence는 크게 &lt;strong&gt;RAW, WAR, WAW&lt;/strong&gt; 이 세가지로 종류를 나눌 수가 있습니다. 각각의 특징들에 대해서 자세히 살펴봅시다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;RAW(Read-After-Write, True-Dependence)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Write)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Read)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Pipeline-CPU&lt;/strong&gt;는 Multi-Cycle-CPU와 마찬가지로 &lt;strong&gt;IF, ID, EX, MEM, WB&lt;/strong&gt;의 단계들을 거칩니다. 그러나 연속적으로 매 싸이클마다 새로운 Instruction이 들어오는 Pipeline-CPU의 특성상 RAW와 같은 경우가 발생하였을 때, &lt;strong&gt;Write($x2)를 먼저 수행하여야 함에도 불구하고, Write가 되어지지 않은 $x2 레지스터 값을 먼저 읽어오는 매우 심각한 Hazard&lt;/strong&gt;가 발생합니다.&lt;/p&gt;

&lt;p&gt;따라서 연속적인 Instruction들이 쏟아지는 Pipeline-CPU를 완벽하게 작동시키기 위해서는 &lt;strong&gt;RAW Hazard&lt;/strong&gt;를 어떻게 처리하여야 할지 고민해야 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;WAR(Write-After-Read, Anti-Dependence)&lt;/li&gt;
    &lt;li&gt;WAW(Write-After-Write, Output-Dependence)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* WAR */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Read)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Write)&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* WAW */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Write)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Write)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;WAR와 WAW&lt;/strong&gt;는 함께 묶어서 &lt;strong&gt;False dependency&lt;/strong&gt;라고 합니다. Pipeline CPU에서 instruction의 실행 순서상 &lt;strong&gt;read 가 IF/ID에서 항상 먼저&lt;/strong&gt; 실행된 다음에 &lt;strong&gt;WB단계에서 Write가&lt;/strong&gt; 됩니다. 이러한 Pipeline-CPU의 특성상 False dependency의 경우는 &lt;strong&gt;RAW에 해당하는 True data hazard&lt;/strong&gt;에 해당되지 않습니다.&lt;/p&gt;

&lt;p&gt;따라서 &lt;strong&gt;False dependency(WAW, WAR)&lt;/strong&gt;은 레지스터에 저장된 &lt;strong&gt;data&lt;/strong&gt;로 인해 발생되는 문제가 아닌 &lt;strong&gt;레지스터의 name&lt;/strong&gt;과 관계된 문제라고 이해를 하면 됩니다. &lt;strong&gt;False dependence(WAR, WAW)&lt;/strong&gt;의 경우, 만약 무한히 많은 레지스터가 있다면 레지스터를 다음과 같이 &lt;strong&gt;Renaming&lt;/strong&gt;함으로 써 문제를 &lt;strong&gt;concurrent-processing&lt;/strong&gt;에서 발생할 수 있는 문제들을 해결할 수 있게 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Renaming 전 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Read)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Write)&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Renaming 후 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2(Read)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// $x2--&amp;gt;$x8(Write)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;raw-hazard&quot;&gt;RAW Hazard&lt;/h2&gt;

&lt;p&gt;앞서 살펴본 세가지 &lt;strong&gt;Data dependence&lt;/strong&gt;의 경우 중 하나인 &lt;strong&gt;RAW Hazard&lt;/strong&gt;에 대해 자세히 살펴봅시다. &lt;strong&gt;RAW&lt;/strong&gt;의 경우는 &lt;strong&gt;Write를 먼저하고 Read를 꼭 해야하기 때문에&lt;/strong&gt;, write 가 되기도 전에 다음 Instruction이 &lt;strong&gt;IF/ID에서 read를 할 경우&lt;/strong&gt; Data Hazard가 발생하므로 이러한 Hazard가 생기는 것을 미리 방지해 주어야 합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 우선, CPU는 RAW Hazard가 발생하였다는 사실을 어떻게 알 수 있을까요?&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*RAW Hazard 발생 조건 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I_OLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I_YOUNG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// I(young) ex) R/I, LD, SD, Bxx, JALR // Read Instruction Operator&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// I(old)  ex) R/I, LD, JAL, JALR // Write Instruction Operator&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* write(old instructiion) 보다 read(young instruction)가 먼저 수행될경우 hazard가 발생한다.
dist 가 3 보다 큰 경우는 hazard가 발생하지 않으므로 3 이하인 경우만 고려 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/122864196-2588ac80-d35f-11eb-99ed-f855f6466f5e.png&quot; width=&quot;800&quot; /&gt;&lt;br /&gt;Feature2. RAW detection Logic
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RAW(Read after Write)&lt;/strong&gt; dependency인 경우에, Data Hazard가 발생하지 않기 위해서는 Write를 먼저 한 이후에 Read Instruction이 수행되어야 합니다. 하지만 &lt;strong&gt;Pipeline-CPU는 RAW가 발생한 두 instruction 간의 거리가 3이하일 경우에는 항상 I_YOUNG의 Read가 Write 되기도 전에 먼저 실행이 되는 Hazard가 발생하게 됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서 &lt;strong&gt;Feature2&lt;/strong&gt;에서 확인할 수 있듯이, Write Operator에 해당하는 Instruction과 Read Operator에 해당하는 Instruction 간의 &lt;strong&gt;거리&lt;/strong&gt;를 확인 함으로써 RAW Hazard가 발생할거라는 사실을 확인할 수가 있습니다.&lt;/p&gt;

&lt;p&gt;CPU가 RAW Hazard가 발생하였다는 사실을 알아챘다면, 어떻게 Data Hazard 문제를 해결할 수가 있을까요?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Wed, 23 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-3/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-3/</guid>
        
        <category>data hazard</category>
        
        <category>RAW</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        <category>RAW Hazrd</category>
        
        <category>Branch Prediction</category>
        
        <category>2-bit global</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>Pipeline CPU(2) Pipeline-CPU의 간략한 이해</title>
        <description>&lt;blockquote&gt;
  &lt;h3 id=&quot;pipeline-cpu-목차&quot;&gt;Pipeline-CPU 목차&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Pipeline CPU(1) : Single-Cycle vs Multi-Cycle CPU&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-2/&quot;&gt;Pipeline CPU(2) : Pipeline-CPU의 간략한 이해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-3/&quot;&gt;Pipeline CPU(3) : Data Hazard&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;앞서 Pipeline CPU를 design 해보기 위한 준비과정으로
&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Single-Cycle CPU와 Multi-Cycle CPU의 특성&lt;/a&gt;들을 먼저 살펴보았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pipeline-cpu의-전체적-그림&quot;&gt;Pipeline CPU의 전체적 그림&lt;/h3&gt;

&lt;p&gt;Pipeline-CPU은 사실 Multi-Cycle-CPU에서 부터 출발합니다.
하지만, 어떤 면에서 더 우월한 점이 있을까요?&lt;/p&gt;

&lt;h3 id=&quot;한-번에-한-가지-일만을-수행하는-multi-cycle-cpu&quot;&gt;한 번에 한 가지 일만을 수행하는 Multi-Cycle-CPU&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121612871-47984a00-ca96-11eb-987a-bab3fc7f6bd2.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature1. Multi-Cycle-CPU overview 비유
&lt;/p&gt;
&lt;p&gt;옷을 빨래하는 과정을 떠올려봅시다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;세탁기를 돌린다.&lt;/li&gt;
    &lt;li&gt;건조기를 돌린다.&lt;/li&gt;
    &lt;li&gt;옷을 잘 정리한다.&lt;/li&gt;
    &lt;li&gt;옷을 옷장에 잘 정리한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;빨래&lt;/strong&gt;라는 일을 수행하기 위해 우리는 4가지 작업을 수행해야합니다. 하지만 내가 옷을 잘 정리할 동안, 멈춰있는 세탁기와 건조기를 사용할 수 있다면 어떨까요?&lt;br /&gt;
즉, 다시 말해 한 번에 여러가지의 작업을 동시에 수행한다면 &lt;strong&gt;빨래&lt;/strong&gt;라는 일을 더 빠르게 수행할 수 있을 것입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121613409-592e2180-ca97-11eb-8aea-34b283cb6565.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature2. Pipelined Laundry
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Feature2&lt;/strong&gt;에서 확인할 수 있듯이, pipelining을 통해 한 번에 여러가지의 작업을 동시에
수행할 수 있게 되었습니다. 그 결과 &lt;strong&gt;빨래&lt;/strong&gt;를 4번 수행하려면 8시간 걸리던 일이, Pipelining을 통한 구현으로 3시간 30분만에 수행할 수 있게되었습니다.&lt;/p&gt;

&lt;p&gt;따라서, Pipelining을 통해서 CPU의 &lt;strong&gt;Throughput&lt;/strong&gt;을 증가시키고 &lt;strong&gt;하드에웨어 자원들을 더욱 효율적&lt;/strong&gt;으로 사용이 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;overview-of-pipeline-cpu&quot;&gt;Overview of Pipeline-CPU&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121613807-4d8f2a80-ca98-11eb-9061-42b97cab8dbe.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature3. Graphical View
&lt;/p&gt;
&lt;p&gt;위의 &lt;strong&gt;Feature3&lt;/strong&gt;을 한 번 살펴봅시다. &lt;strong&gt;LD, SUB, ADD&lt;/strong&gt; 등의 새로운 &lt;strong&gt;Instruction이&lt;/strong&gt; &lt;strong&gt;CC시간&lt;/strong&gt; 마다 계속해서 CPU에 입력되고 있습니다. 이전의 &lt;strong&gt;Single-Cycle-CPU&lt;/strong&gt;와 &lt;strong&gt;Multi-Cycle-CPU&lt;/strong&gt; 였다면 &lt;strong&gt;LD Instr&lt;/strong&gt;이 끝날때까지 다음의 &lt;strong&gt;SUB Instr&lt;/strong&gt;은 대기하고 있어야만 하였습니다.&lt;/p&gt;

&lt;p&gt;이제는 &lt;strong&gt;Pipelining을&lt;/strong&gt; 통해서 일정 간격으로 새로운 Instr을 연속적으로 수행할 수 있게 되었습니다. CC5가 되는 순간에는 &lt;strong&gt;WB, MEM, EX, ID, IF&lt;/strong&gt; 의 모든 Stage가 동시에 수행되는 것을 확인할 수가 있는데요. 이처럼 CPU에 주어진 HW resource를 모두 최대한으로 활용하는 것을 확인할 수가 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;문제는-지금부터&quot;&gt;문제는 지금부터…&lt;/h3&gt;

&lt;p&gt;그러나 매번 새롭게 들어오는 Instruction을 CPU는 어떻게 잘 수행할 수 있을까요?
위의 CC5 시점의 경우 동시간에 5개의 Instr이 수행되고 있습니다. 이때, EX stage는 5개의 Instr 중에 어느 것을 수행하여 ALU 계산을 해야할까요?&lt;/p&gt;

&lt;p&gt;또한 만약, 앞에서 수행한 Instr의 결과를 그대로 받아와서 다음 Instr에 수행하는 경우가 있을 때,
계산 결과가 레지스터에 저장되지 않았는데도 불구하고 계산을 하라는 명령을 CPU가 받게 되면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;그렇습니다. 여기서 부터 Pipeline-CPU를 정상적으로 잘 작동시키기 위해서 무엇보다 중요한 다음의 세가지 주요 사항을 짚어 넘어가야 합니다.&lt;/p&gt;

&lt;p&gt;각 중요 사항들에 대해서 다음 Post에서 계속해서 알아봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Fri, 11 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-2/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-2/</guid>
        
        <category>computer architecture</category>
        
        <category>computer science</category>
        
        <category>single cycle</category>
        
        <category>single cycle cpu</category>
        
        <category>multi cycle</category>
        
        <category>multi cycle cpu</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>Pipeline CPU(1) &lt;br&gt; Single_Cycle_CPU VS Multi_Cycle_CPU</title>
        <description>&lt;blockquote&gt;
  &lt;h3 id=&quot;pipeline-cpu-목차&quot;&gt;Pipeline-CPU 목차&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Pipeline CPU(1) : Single-Cycle vs Multi-Cycle CPU&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-2/&quot;&gt;Pipeline CPU(2) : Pipeline-CPU의 간략한 이해&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;/computer-architecture/pipeline-3/&quot;&gt;Pipeline CPU(3) : Data Hazard&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Pipeline CPU를 design &amp;amp; implement 하기 위해서는&lt;br /&gt;
&lt;strong&gt;Single-Cycle과 Multi-Cycle CPU&lt;/strong&gt;의 특성들을 이해하는 것이 필요합니다.
어떠한 특성으로 인해 Pipeline-CPU가 가장 빠르게 작동할 수 있을까요?&lt;/p&gt;

&lt;h1 id=&quot;single-cycle-cpu-의-비효율성&quot;&gt;Single-Cycle CPU 의 비효율성&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Instruction 마다의 특성을 고려하지 못한 Single-Cycle-CPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Single-Cycle CPU 의 경우에는 새로운 Instruction이 입력되고 다음 Instruction이 입력될 때까지 &lt;strong&gt;Single cycle time&lt;/strong&gt;이 소요됩니다.
&lt;strong&gt;하지만 여기서 모든 Instruction들이 동일한 Single Cycle Time으로 작동하기 때문에 비효율성 문제가 발생합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 JAL과 LD, 이 두가지 Instruction을 자세히 비교하여 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//TSC Manual을 기준으로 설명을 하겠습니다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;JAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
JAL의 경우는 현재 PC의 상위 4bit와 나머지
unsigned target offset(Immediate value) 12bit를 붙여서 NextPC 가 됩니다.
그 후에 $2 레지스터에 PC+1(기존의 다음 PC address)를 저장합니다.
(일종의 return address 용도로 사용하기 위함입니다.)
*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LD&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
LD의 경우는 $rs 레지스터의 value와 offset(Immediate value)를
더한 값을 메모리의 주소로하여 해당 메모리 위치에 존재하는 값을
$rt 레지스터에 저장합니다.
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JAL&lt;/strong&gt;는 &lt;strong&gt;IF, EX, WB 3가지 단계&lt;/strong&gt;만을 필요로 합니다.&lt;br /&gt;
&lt;strong&gt;LD&lt;/strong&gt;는 &lt;strong&gt;IF, ID, EX, MEM, WB 모든 단계&lt;/strong&gt;를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JAL&lt;/strong&gt;은 IF 단계를 거쳐, 레지스터를 읽어오는 ID 단계가 필요 없이 EX 단계에서 target address를 계산하고 그 후에 WB 단계에서 $2 레지스터에 PC값을 저장합니다.&lt;/p&gt;

&lt;p&gt;반면에 &lt;strong&gt;LD&lt;/strong&gt;는 IF, ID(레지스터로부터 read), EX(메모리 target address 계산), MEM(해당 위치의 메모리 read), WB(읽어온 값 저장)을 수행합니다.&lt;/p&gt;

&lt;p&gt;JAL과 LD는 모두 하나의 instruction을 수행하며 &lt;strong&gt;Single Cycle Time&lt;/strong&gt;을 필요로 합니다.&lt;br /&gt;
그러나, JAL은 LD보다 더 적은 단계들을 거쳐 더욱 빠르게 Instruction을 수행할 수가 있었습니다.
하지만, Single-Cycle CPU는 &lt;strong&gt;가장 오랜 시간이 소요되는 Instruction을 기준&lt;/strong&gt;으로&lt;br /&gt;
작동하여야 모든 Instruction을 Single-Cycle 동안 수행할 수가 있기 때문에 이러한 비효율성 문제가 발생합니다.&lt;/p&gt;

&lt;h1 id=&quot;single-cycle-cpu를-개선한-multi-cycle-cpu&quot;&gt;Single-Cycle-CPU를 개선한 Multi-Cycle CPU&lt;/h1&gt;

&lt;p&gt;위와 같은 Single-Cycle-CPU의 문제점을 개선하여 Design 한 것이 Multi-Cycle-CPU 입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/118086618-3ad4f780-b3ff-11eb-803f-2a5c7db53828.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;Feature1. Single Cycle vs Multi Cycle
&lt;/p&gt;
&lt;p&gt;두가지 모두 4개의 Instruction을 실행하였지만, Multi-Cycle CPU가 확연하게 더 빠르게 수행하였음을 확인할 수가 있습니다.
그 이유는 Multi-Cycle-CPU는 cycle time을 아주 작게 설정하였기 때문입니다. 각 Instruction의 특성에 맞게
필요한 만큼의 Cycle 동안 작동하기 때문에 Single-Cycle의 비효율성 문제를 개선할 수가 있습니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/118087617-c56a2680-b400-11eb-8e40-228ecfcc457b.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;Feature2. FSM Multi Cycle
&lt;/p&gt;
&lt;p&gt;Multi-Cycle CPU는 &lt;strong&gt;Mealy Finite State Machine&lt;/strong&gt;으로 구현할 수가 있습니다.
각 State는 1 cycle time을 필요로 하고, FSM는 &lt;strong&gt;Instruction의 특성에 맞게 필요없는 Stage는 Skip&lt;/strong&gt;하며
작동하기 때문에 더욱 효율적인 Instruction 수행이 가능합니다.&lt;/p&gt;

&lt;h1 id=&quot;multi-cycle-cpu를-개선한-pipeline-cpu&quot;&gt;Multi-Cycle-CPU를 개선한 Pipeline-CPU&lt;/h1&gt;

&lt;p&gt;Multi-Cycle-CPU를 더 개선할 수는 없을까요?&lt;/p&gt;

&lt;p&gt;Multi-Cycle-CPU는 Instruction 들의 특성에 맞는 &lt;strong&gt;시간&lt;/strong&gt;의 효율성에 초점을 두었습니다.
Pipeline-CPU는 &lt;strong&gt;시간&lt;/strong&gt;뿐만아니라 &lt;strong&gt;resource&lt;/strong&gt;의 효율성 또한 고려한 것 입니다.&lt;/p&gt;

&lt;p&gt;Multi-Cycle-CPU에서 ADD Instruction이 EX단계에서 구현되고 있다고 생각해봅시다.
EX를 제외한 IF, ID, MEM, WB에서 사용되는 레지스터와 메모리 등 여러 resource들은 모두 작동하지 않고 멈춰있는 상황입니다.&lt;/p&gt;

&lt;p&gt;Pipeline-CPU는 &lt;strong&gt;resource들을 쉴틈없이 계속해서&lt;/strong&gt; 작동하도록 구현한 것 입니다.
그렇기 때문에 같은 시간동안 모든 자원들을 최대한으로 사용하기 때문에 더 많은 Instruction들을 수행할 수가 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 여기서 Pipeline-CPU에서 가장 머리아픈 &lt;strong&gt;Hazard&lt;/strong&gt; 문제가 발생합니다.&lt;br /&gt;
빠르기만 하고 Instruction의 결과가 모두 순엉터리라면 도움이 안되는 CPU이기 때문입니다.
Pipeline-CPU의 Hazard에 대해서는 새로운 Post에서 정리하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Thu, 13 May 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-1/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-1/</guid>
        
        <category>computer architecture</category>
        
        <category>computer science</category>
        
        <category>single cycle</category>
        
        <category>single cycle cpu</category>
        
        <category>multi cycle</category>
        
        <category>multi cycle cpu</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>React Study(1) 정리</title>
        <description>&lt;h3 id=&quot;component-driven-user-interfaces&quot;&gt;Component-Driven User Interfaces&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;A Client-side JavaScript library&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All aobut building modern, reactive user interfaces for the web&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Building Single-Page-Applications (SPAs)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배워야할-개념들&quot;&gt;배워야할 개념들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Components &amp;amp; Building UIs&lt;/li&gt;
  &lt;li&gt;Working with Events &amp;amp; Data: “props” and “state”&lt;/li&gt;
  &lt;li&gt;Styling React Apps &amp;amp; Components&lt;/li&gt;
  &lt;li&gt;React Hooks&lt;/li&gt;
  &lt;li&gt;React Redux&lt;/li&gt;
  &lt;li&gt;Http Requests &amp;amp; Custom Hooks&lt;/li&gt;
  &lt;li&gt;Routing, Deployment, NextJS &amp;amp; etc&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component&quot;&gt;Component&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;functional programming의 개념&lt;/li&gt;
  &lt;li&gt;Reusability&lt;/li&gt;
  &lt;li&gt;reactive components consited of HTML and JavaScript (and CSS)&lt;/li&gt;
  &lt;li&gt;Define the desired target state&lt;/li&gt;
  &lt;li&gt;let React figure out the actual JAvaScript Dom instructions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;6월-13일&quot;&gt;6월 13일&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;29번. JSX javascript XML
developer friendly code를 가능하게 해주는 것.
Component in React is just a JavaScript function.
사용자 정의된 Component는 Upper case로 시작해야한다.
Lower case로 시작한 것은 div 이런 기본 element들로 인식.
하나의 컴포넌트는 하나의 root element를 소유해야만 한다.
React로 render 한 이후에 element view된 값들을 수정하려면 일반적인 함수를 통한 방법으로는 다시 re-render(reevaluation) 되지 않는다. 왜냐하면 element가 event가 발생한 사실을 알 수가 없기 때문이다. 따라서 State가 필요하다.
state를 update할 때 previous state를 즉 가장 최근의 data를 update하도록 잘 설정해주어야 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;styledComponents
cssModule&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;React.Fragments : wrapper for preventing from nested div problems(unnecessary many div_s).
React Portal: ex) Modal hierarchy
Controlled vs UnControlled Component&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;useEffect Hook 잘 이해하기 !!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;useEffect() Hook!! : To re-run logic when some specific data has been changed(change is detected)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;debouncing: to check whether user is done keystroking
useEffect() 함수 내에서 return () =&amp;gt; {} 의 함수는 다시한번 useEffect가 호출되기 직전에 return안의 함수가 실행된다. 처음에은 실행X. 따라서 return 안에는 cleanUp해주는 함수들을 정의해서 넣어주면 된다.(ex clearTimeout…)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;useReducer Hook!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;useState에서 만약 다른 state 값을 접근하여 state값을 변경하도록 하는 로직이라면 잘 못 작성한 useState사용 방식이다(룰에 어긋남, 다른 state가 도중에 변경되는 sync가 안 맞을 수도 있는 그런 경우 때문인듯), 그래서 이 경우에 useReducer를 사용할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;React Context!&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;data forwarding을 위해서 아무 의미없이 컴포넌트가 dat의 forward역할 (거쳐가는 통로)로만 사용되면 big project(huge project)일 때 너무 번거롭고 오류가 생길 수 있기에 React Context를 사용하면 유용하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;long-prop-chain 문제를 해결가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;p&gt;React Hook Rules&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;React Hook은 React 컴포넌트 내에서만 사용가능하다.
React Hook은 컴포넌트의 Top level에서 call해야한다.(nested hooks are not allowed)&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/react/react-study-1/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/react/react-study-1/</guid>
        
        <category>React</category>
        
        <category>JS</category>
        
        <category>Web Framework</category>
        
        
        <category>React</category>
        
      </item>
    
  </channel>
</rss>