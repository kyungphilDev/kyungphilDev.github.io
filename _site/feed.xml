<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>KyungPhil Dev</title>
    <description>Computer Science Dept</description>
    <link>https://kyungphildev.github.io/</link>
    <atom:link href="https://kyungphildev.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 11 Jun 2021 10:23:53 +0900</pubDate>
    <lastBuildDate>Fri, 11 Jun 2021 10:23:53 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Pipeline CPU(2) Pipeline-CPU의 간략한 이해</title>
        <description>&lt;p&gt;앞서 Pipeline CPU를 design 해보기 위한 준비과정으로
&lt;a href=&quot;/computer-architecture/pipeline-1/&quot;&gt;Single-Cycle CPU와 Multi-Cycle CPU의 특성&lt;/a&gt;들을 먼저 살펴보았습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pipeline-cpu의-전체적-그림&quot;&gt;Pipeline CPU의 전체적 그림&lt;/h3&gt;

&lt;p&gt;Pipeline-CPU은 사실 Multi-Cycle-CPU에서 부터 출발합니다.
하지만, 어떤 면에서 더 우월한 점이 있을까요?&lt;/p&gt;

&lt;h3 id=&quot;한-번에-한-가지-일만을-수행하는-multi-cycle-cpu&quot;&gt;한 번에 한 가지 일만을 수행하는 Multi-Cycle-CPU&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121612871-47984a00-ca96-11eb-987a-bab3fc7f6bd2.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature1. Multi-Cycle-CPU overview 비유
&lt;/p&gt;
&lt;p&gt;옷을 빨래하는 과정을 떠올려봅시다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;세탁기를 돌린다.&lt;/li&gt;
    &lt;li&gt;건조기를 돌린다.&lt;/li&gt;
    &lt;li&gt;옷을 잘 정리한다.&lt;/li&gt;
    &lt;li&gt;옷을 옷장에 잘 정리한다.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;빨래&lt;/strong&gt;라는 일을 수행하기 위해 우리는 4가지 작업을 수행해야합니다. 하지만 내가 옷을 잘 정리할 동안, 멈춰있는 세탁기와 건조기를 사용할 수 있다면 어떨까요?&lt;br /&gt;
즉, 다시말해 한 번에 여러가지의 작업을 동시에 수행한다면 &lt;strong&gt;빨래&lt;/strong&gt;라는 일을 더 빠르게 많이 수행할수 있을 것입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121613409-592e2180-ca97-11eb-8aea-34b283cb6565.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature2. Pipelined Laundry
&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Feature2&lt;/strong&gt;에서 확인할 수 있듯이, pipelining을 통해 한 번에 여러가지의 작업을 동시에
수행할 수 있게 되었습니다. 그 결과 &lt;strong&gt;빨래&lt;/strong&gt;를 4번 수행하려면 8시간 걸리던 일이, Pipelining을 통한 구현으로 3시간 30분만에 수행할 수 있게되었습니다.&lt;/p&gt;

&lt;p&gt;따라서 Pipeline을 통해서 &lt;strong&gt;Throughput&lt;/strong&gt;을 증가시키고 &lt;strong&gt;HW를 더욱 효율적&lt;/strong&gt;으로 사용이 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;overview-of-pipeline-cpu&quot;&gt;Overview of Pipeline-CPU&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/121613807-4d8f2a80-ca98-11eb-9061-42b97cab8dbe.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature3. Graphical View
&lt;/p&gt;
&lt;p&gt;위의 &lt;strong&gt;Feature3&lt;/strong&gt;을 한 번 살펴봅시다. &lt;strong&gt;LD, SUB, ADD&lt;/strong&gt; 등의 새로운 &lt;strong&gt;Instruction이&lt;/strong&gt; &lt;strong&gt;CC시간&lt;/strong&gt; 마다 계속에서 CPU에 입력하고 있습니다. 이전의 &lt;strong&gt;Single-Cycle-CPU&lt;/strong&gt;와 &lt;strong&gt;Multi-Cycle-CPU&lt;/strong&gt; 였다면 LD Instr이 끝날때까지 다음의 SUB Instr은 대기하고 있어야만 하였습니다. 하지만 &lt;strong&gt;Pipelining을&lt;/strong&gt; 통해서 일정 간격으로 새로운 Instr을 잘 수행할 수 가 있게 되었습니다. CC5가 되는 순간에는 &lt;strong&gt;WB, MEM, EX, ID, IF&lt;/strong&gt; 의 모든 Stage가 동시에 수행되는 것을 확인할 수가 있는데요. 이처럼 이제는 CPU에 주어진 HW resource들도 모두 최대한으로 활용하는 것을 확인할 수가 있습니다.
—&lt;/p&gt;

&lt;h3 id=&quot;문제는-지금부터&quot;&gt;문제는 지금부터…&lt;/h3&gt;

&lt;p&gt;그러나 매번 새롭게 들어오는 Instr을 CPU는 어떻게 각 입력의 특성에 맞게 잘 수행할 수 있을까요?
위의 CC5 시점의 경우 동시간에 5개의 Instr이 수행되고 있습니다. 이때, EX stage는 5개의 Instr 중에 어느 것을 수행하여 ALU 계산을 해야할까요?&lt;/p&gt;

&lt;p&gt;또한 만약, 앞에서 수행한 Instr의 결과를 그대로 받아와서 다음 Instr에 수행하는 경우가 있을 때,
계산 결과가 레지스터에 저장되지 않았는데도 불구하고 계산을 하라는 명령을 CPU가 받게 되면 어떻게 될까요?&lt;/p&gt;

&lt;p&gt;그렇습니다. 여기서 부터 Pipeline-CPU를 정상적으로 잘 작동시키기 위해서 무엇보다 중요한 다음의 세가지 주요 사항을 짚어 넘어가야 합니다.&lt;/p&gt;

&lt;p&gt;각 중요 사항들에 대해서 다음 Post에서 계속해서 알아봅시다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Fri, 11 Jun 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-2/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-2/</guid>
        
        <category>computer architecture</category>
        
        <category>computer science</category>
        
        <category>single cycle</category>
        
        <category>single cycle cpu</category>
        
        <category>multi cycle</category>
        
        <category>multi cycle cpu</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>Pipeline CPU(1) &lt;br&gt; Single_Cycle_CPU VS Multi_Cycle_CPU</title>
        <description>&lt;p&gt;Pipeline CPU를 design &amp;amp; implement 하기 위해서는&lt;br /&gt;
&lt;strong&gt;Single-Cycle과 Multi-Cycle CPU&lt;/strong&gt;의 특성들을 이해하는 것이 필요합니다.&lt;/p&gt;

&lt;p&gt;어떠한 특성으로 인해 Pipeline-CPU가 가장 빠르게 작동할 수 있을까요?&lt;/p&gt;

&lt;h1 id=&quot;single-cycle-cpu-의-비효율성&quot;&gt;Single-Cycle CPU 의 비효율성&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Instruction 마다의 특성을 고려하지 못한 Single-Cycle-CPU&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Single-Cycle CPU 의 경우에는 새로운 Instruction이 입력되고 다음 Instruction이 입력될 때까지 &lt;strong&gt;Single cycle time&lt;/strong&gt;이 소요됩니다.
&lt;strong&gt;하지만 여기서 모든 Instruction들이 동일한 Single Cycle Time으로 작동하기 때문에 비효율성 문제가 발생합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 JAL과 LD, 이 두가지 Instruction을 자세히 비교하여 봅시다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//TSC Manual을 기준으로 설명을 하겠습니다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;JAL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
JAL의 경우는 현재 PC의 상위 4bit와 나머지
unsigned target offset(Immediate value) 12bit를 붙여서 NextPC 가 됩니다.
그 후에 $2 레지스터에 PC+1(기존의 다음 PC address)를 저장합니다.
(일종의 return address 용도로 사용하기 위함입니다.)
*/&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;LD&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
LD의 경우는 $rs 레지스터의 value와 offset(Immediate value)를
더한 값을 메모리의 주소로하여 해당 메모리 위치에 존재하는 값을
$rt 레지스터에 저장합니다.
*/&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;JAL&lt;/strong&gt;는 &lt;strong&gt;IF, EX, WB 3가지 단계&lt;/strong&gt;만을 필요로 합니다.&lt;br /&gt;
&lt;strong&gt;LD&lt;/strong&gt;는 &lt;strong&gt;IF, ID, EX, MEM, WB 모든 단계&lt;/strong&gt;를 필요로 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JAL&lt;/strong&gt;은 IF 단계를 거쳐, 레지스터를 읽어오는 ID 단계가 필요 없이 EX 단계에서 target address를 계산하고 그 후에 WB 단계에서 $2 레지스터에 PC값을 저장합니다.&lt;/p&gt;

&lt;p&gt;반면에 &lt;strong&gt;LD&lt;/strong&gt;는 IF, ID(레지스터로부터 read), EX(메모리 target address 계산), MEM(해당 위치의 메모리 read), WB(읽어온 값 저장)을 수행합니다.&lt;/p&gt;

&lt;p&gt;JAL과 LD는 모두 하나의 instruction을 수행하며 &lt;strong&gt;Single Cycle Time&lt;/strong&gt;을 필요로 합니다.&lt;br /&gt;
그러나, JAL은 LD보다 더 적은 단계들을 거쳐 더욱 빠르게 Instruction을 수행할 수가 있었습니다.
하지만, Single-Cycle CPU는 &lt;strong&gt;가장 오랜 시간이 소요되는 Instruction을 기준&lt;/strong&gt;으로&lt;br /&gt;
작동하여야 모든 Instruction을 Single-Cycle 동안 수행할 수가 있기 때문에 이러한 비효율성 문제가 발생합니다.&lt;/p&gt;

&lt;h1 id=&quot;single-cycle-cpu를-개선한-multi-cycle-cpu&quot;&gt;Single-Cycle-CPU를 개선한 Multi-Cycle CPU&lt;/h1&gt;

&lt;p&gt;위와 같은 Single-Cycle-CPU의 문제점을 개선하여 Design 한 것이 Multi-Cycle-CPU 입니다.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/118086618-3ad4f780-b3ff-11eb-803f-2a5c7db53828.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;Feature1. Single Cycle vs Multi Cycle
&lt;/p&gt;
&lt;p&gt;두가지 모두 4개의 Instruction을 실행하였지만, Multi-Cycle CPU가 확연하게 더 빠르게 수행하였음을 확인할 수가 있습니다.
그 이유는 Multi-Cycle-CPU는 cycle time을 아주 작게 설정하였기 때문입니다. 각 Instruction의 특성에 맞게
필요한 만큼의 Cycle 동안 작동하기 때문에 Single-Cycle의 비효율성 문제를 개선할 수가 있습니다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/118087617-c56a2680-b400-11eb-8e40-228ecfcc457b.png&quot; width=&quot;600&quot; /&gt;&lt;br /&gt;Feature2. FSM Multi Cycle
&lt;/p&gt;
&lt;p&gt;Multi-Cycle CPU는 &lt;strong&gt;Mealy Finite State Machine&lt;/strong&gt;으로 구현할 수가 있습니다.
각 State는 1 cycle time을 필요로 하고, FSM는 &lt;strong&gt;Instruction의 특성에 맞게 필요없는 Stage는 Skip&lt;/strong&gt;하며
작동하기 때문에 더욱 효율적인 Instruction 수행이 가능합니다.&lt;/p&gt;

&lt;h1 id=&quot;multi-cycle-cpu를-개선한-pipeline-cpu&quot;&gt;Multi-Cycle-CPU를 개선한 Pipeline-CPU&lt;/h1&gt;

&lt;p&gt;Multi-Cycle-CPU를 더 개선할 수는 없을까요?&lt;/p&gt;

&lt;p&gt;Multi-Cycle-CPU는 Instruction 들의 특성에 맞는 &lt;strong&gt;시간&lt;/strong&gt;의 효율성에 초점을 두었습니다.
Pipeline-CPU는 &lt;strong&gt;시간&lt;/strong&gt;뿐만아니라 &lt;strong&gt;resource&lt;/strong&gt;의 효율성 또한 고려한 것 입니다.&lt;/p&gt;

&lt;p&gt;Multi-Cycle-CPU에서 ADD Instruction이 EX단계에서 구현되고 있다고 생각해봅시다.
EX를 제외한 IF, ID, MEM, WB에서 사용되는 레지스터와 메모리 등 여러 resource들은 모두 작동하지 않고 멈춰있는 상황입니다.&lt;/p&gt;

&lt;p&gt;Pipeline-CPU는 &lt;strong&gt;resource들을 쉴틈없이 계속해서&lt;/strong&gt; 작동하도록 구현한 것 입니다.
그렇기 때문에 같은 시간동안 모든 자원들을 최대한으로 사용하기 때문에 더 많은 Instruction들을 수행할 수가 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 여기서 Pipeline-CPU에서 가장 머리아픈 &lt;strong&gt;Hazard&lt;/strong&gt; 문제가 발생합니다.&lt;br /&gt;
빠르기만 하고 Instruction의 결과가 모두 순엉터리라면 도움이 안되는 CPU이기 때문입니다.
Pipeline-CPU의 Hazard에 대해서는 새로운 Post에서 정리하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Thu, 13 May 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/pipeline-1/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/pipeline-1/</guid>
        
        <category>computer architecture</category>
        
        <category>computer science</category>
        
        <category>single cycle</category>
        
        <category>single cycle cpu</category>
        
        <category>multi cycle</category>
        
        <category>multi cycle cpu</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
      <item>
        <title>React Study(1) 정리</title>
        <description>&lt;h3 id=&quot;component-driven-user-interfaces&quot;&gt;Component-Driven User Interfaces&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;A Client-side JavaScript library&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;All aobut building modern, reactive user interfaces for the web&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Building Single-Page-Applications (SPAs)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;배워야할-개념들&quot;&gt;배워야할 개념들&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Components &amp;amp; Building UIs&lt;/li&gt;
  &lt;li&gt;Working with Events &amp;amp; Data: “props” and “state”&lt;/li&gt;
  &lt;li&gt;Styling React Apps &amp;amp; Components&lt;/li&gt;
  &lt;li&gt;React Hooks&lt;/li&gt;
  &lt;li&gt;React Redux&lt;/li&gt;
  &lt;li&gt;Http Requests &amp;amp; Custom Hooks&lt;/li&gt;
  &lt;li&gt;Routing, Deployment, NextJS &amp;amp; etc&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;component&quot;&gt;Component&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;functional programming의 개념&lt;/li&gt;
  &lt;li&gt;Reusability&lt;/li&gt;
  &lt;li&gt;reactive components consited of HTML and JavaScript (and CSS)&lt;/li&gt;
  &lt;li&gt;Define the desired target state&lt;/li&gt;
  &lt;li&gt;let React figure out the actual JAvaScript Dom instructions&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 12 May 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/react/react-study-1/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/react/react-study-1/</guid>
        
        <category>React</category>
        
        <category>JS</category>
        
        <category>Web Framework</category>
        
        
        <category>React</category>
        
      </item>
    
      <item>
        <title>Pipeline CPU(3)- Data Hazard</title>
        <description>&lt;h3 id=&quot;세가지-주요-사항&quot;&gt;세가지 주요 사항&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Data Hazard&lt;/li&gt;
  &lt;li&gt;Control Hazard&lt;/li&gt;
  &lt;li&gt;Branch Prediction&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;이번 Post에서는 위의 세가지 주요 특징들 중에서도&lt;br /&gt;
&lt;strong&gt;1. Data Hazard&lt;/strong&gt;
를 해결하는 방법에 대해 구체적으로 알아 봅니다.&lt;/p&gt;

&lt;h3 id=&quot;raw-hazard-조건&quot;&gt;RAW Hazard 조건&lt;/h3&gt;

&lt;p&gt;우선 WAR이나 WAW의 경우, Pipeline CPU에서 instruction의 실행 순서상 read 가 IF/ID에서 항상 먼저 실행된 다음에 Write가 되기 때문에 Instruction에 방해되는 요소가 아니므로 고려하지 않습니다.&lt;/p&gt;

&lt;p&gt;하지만 &lt;strong&gt;RAW&lt;/strong&gt;의 경우는 &lt;strong&gt;Write를 먼저하고 Read를 꼭 해야하기 때문에&lt;/strong&gt;, write 가 되기도 전에 IF/ID에서 read를 할 경우 문제가 발생하므로 이 경우를 해결해 주어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//RAW Hazard 발생 조건&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//write(old instructiion) 보다 read(young instruction)가 먼저 수행될경우 hazard가 발생한다.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;young&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bxx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JALR&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Read Instruction&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;LD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;JALR&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Write&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I_OLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;I_YOUNG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist 가 3 보다 큰 경우는 hazard가 발생하지 않으므로 3 이하인 경우만 고려&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;data-forwarding-logic&quot;&gt;Data Forwarding Logic&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/116329894-40c7b780-a807-11eb-8e9e-7580d0685266.png&quot; width=&quot;400&quot; /&gt;&lt;br /&gt;Feature1. Forwarding diagram
&lt;/p&gt;
&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegWrite_MEM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist=1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs_EX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_WB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegWrite_WB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stage&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// dist=2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;register&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//dist=3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(마찬가지로 rs2에도 위의 forwarding logic을 수행하면 된다.)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Data Forwarding&lt;/strong&gt; 을 이해하는데 필요한 다음의 두가지 세부 사항을 한번 살펴보자.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1. 가장 최근의 값을 먼저 Forwarding 해주어야 한다.&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;2. use_rs1(IR_ID)는 왜 확인할 필요가 없을까?&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;1-가장-최근의-값을-먼저-forwarding-해주어야-한다&quot;&gt;1. 가장 최근의 값을 먼저 Forwarding 해주어야 한다.&lt;/h3&gt;

&lt;p&gt;다음의 예시의 경우를 한 번 살펴보자&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x5&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1, 2번째와 RAW(x2)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2, 3번째와 RAW(x2)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시와 같은 경우에 만약 3번째 줄을 수행할 때,&lt;br /&gt;
&lt;strong&gt;Data forwarding&lt;/strong&gt;을 &lt;strong&gt;dist=1 보다 dist=2를&lt;/strong&gt; 먼저 수행한다고 가정하여 보자.&lt;br /&gt;
&lt;strong&gt;올바른 계산은 3번째 줄에게 가장 최근인 add를 한 결과를 x2가 받아와야 할 것이다.&lt;/strong&gt;&lt;br /&gt;
하지만, add를 수행하기 전인 &lt;strong&gt;sub의 결과로 부터 x2&lt;/strong&gt;를 읽어오는 forwarding을 수행하기 때문에 올바른 결과값을 갖지 못하게 된다!&lt;/p&gt;

&lt;p&gt;따라서
위의 &lt;strong&gt;Data Forwarding Logic&lt;/strong&gt;에서 확인할 수 있듯이, dist가 적은 1,2,3 즉 가장 가까운 값으로 부터 forwarding을 수행해주어야한다.&lt;/p&gt;

&lt;h3 id=&quot;2-use_rs1ir_id는-왜-확인할-필요가-없을까&quot;&gt;2. use_rs1(IR_ID)는 왜 확인할 필요가 없을까?&lt;/h3&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/116332847-77a0cc00-a80d-11eb-897e-b41e4905fd52.png&quot; width=&quot;400&quot; /&gt;&lt;br /&gt;Feature2. Stall Condition
&lt;/p&gt;
&lt;p&gt;pipeline CPU를 수행하는데 있어서 Data Hazard 문제를 해결하기 위해 Stall 하는 방법이 있었다.
Stall의 조건에는 &lt;strong&gt;use_rs(IR_ID)&lt;/strong&gt; 를 통해 아직 Write 되지 않은 값을 ID에 넣어주는 지를 확인한다.&lt;/p&gt;

&lt;p&gt;하지만 Data Forwarding 에서는 &lt;strong&gt;ID 단계를 Bypass&lt;/strong&gt; 하고 EX에 바로 값을 forwarding 해주기 때문에 use_rs(IR_ID)가 더이상 필요없을 것이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;data-forwarding으로-모든-instructionraw을-해결할-수-있을까&quot;&gt;Data forwarding으로 모든 instruction(RAW)을 해결할 수 있을까?&lt;/h3&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ld&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x7&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// RAW(x2)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 경우 add에서 dist=1 이므로 data forwarding을 해주면 되지만 &lt;strong&gt;LD instruction&lt;/strong&gt;이기 때문에 문제가 발생한다.&lt;br /&gt;
LD instruction의 경우, ALU로 부터 계산된 값이 아닌 &lt;strong&gt;메모리를 Read 한 값을 Forwarding&lt;/strong&gt; 해주어야 하므로 &lt;strong&gt;dist=1&lt;/strong&gt;일때 한 번의 STALL을 필요로 한다.&lt;/p&gt;

&lt;p&gt;따라서 DataForwarding Logic과 함께 다음의 stall 조건을 필요로 한다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Stall&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs1_ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use_rs1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IR_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs2_ID&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rd_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;use_rsw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IR_ID&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MemRead_EX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stall&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//MemRead_EX : op=LD/LW/...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;전체적인-구현-design&quot;&gt;전체적인 구현 Design&lt;/h2&gt;

&lt;p&gt;RAW Hazard를 고려한 Data Forwarding 구현은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Data forwarding&lt;/li&gt;
  &lt;li&gt;Hazard Detection(LD의 경우, STALL)&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;https://user-images.githubusercontent.com/80669616/116356232-f90c5480-a835-11eb-8979-b49dd1ad6250.png&quot; width=&quot;700&quot; /&gt;&lt;br /&gt;Feature3. Pipeline CPU design(Data Forwarding)
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Post의 참고자료와 이미지의 출처는 아래와 같습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Computer Organization and Design RISC-V edition&lt;br /&gt;
Computer Architecrue Lecture Note @ Carnegie Mellon University, University of, Michigan, Purdue University, University of Pennsylvania, University of Wisconsin and POSTECH.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
</description>
        <pubDate>Tue, 27 Apr 2021 00:00:00 +0900</pubDate>
        <link>https://kyungphildev.github.io/computer-architecture/data-hazard/</link>
        <guid isPermaLink="true">https://kyungphildev.github.io/computer-architecture/data-hazard/</guid>
        
        <category>computer architecture</category>
        
        <category>computer science</category>
        
        <category>pipeline</category>
        
        <category>cpu</category>
        
        <category>RAW Hazrd</category>
        
        <category>Branch Prediction</category>
        
        <category>2-bit global</category>
        
        
        <category>Computer-Architecture</category>
        
      </item>
    
  </channel>
</rss>